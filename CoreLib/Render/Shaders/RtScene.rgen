//==============================================================
// RtScene.rgen  (Primary rays)
//==============================================================
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// RT output image: set=2, binding=0
layout(set = 2, binding = 0, rgba8) uniform image2D u_out;

// TLAS: set=2, binding=2
layout(set = 2, binding = 2) uniform accelerationStructureEXT u_tlas;

// Unified camera UBO: set=0, binding=0
layout(set = 0, binding = 0, std140) uniform CameraUBO
{
    mat4 proj;
    mat4 view;
    mat4 viewProj;

    mat4 invProj;
    mat4 invView;
    mat4 invViewProj;

    vec4 camPos;     // world
    vec4 viewport;   // (w, h, 1/w, 1/h)
    vec4 clearColor; // RT clear color
} uCamera;

// Primary ray payload (color)
layout(location = 0) rayPayloadEXT vec4 payload;

void main()
{
    const ivec2 pix  = ivec2(gl_LaunchIDEXT.xy);
    const ivec2 size = ivec2(gl_LaunchSizeEXT.xy);

    vec2 uv  = (vec2(pix) + vec2(0.5)) / vec2(size);
    vec2 ndc = uv * 2.0 - 1.0;

    // Reconstruct world-space ray from invViewProj
    vec4 p0h = uCamera.invViewProj * vec4(ndc, 0.0, 1.0);
    vec4 p1h = uCamera.invViewProj * vec4(ndc, 1.0, 1.0);
    vec3 p0  = p0h.xyz / p0h.w;
    vec3 p1  = p1h.xyz / p1h.w;

    vec3 ro = p0;
    vec3 rd = normalize(p1 - p0);

    payload = uCamera.clearColor;

    // SBT mapping:
    //  - Hit[0]  = primary closest hit
    //  - Miss[0] = primary miss
    traceRayEXT(
        u_tlas,
        gl_RayFlagsOpaqueEXT,
        0xFF,
        0, // sbtRecordOffset -> Hit[0]
        1, // sbtRecordStride
        0, // missIndex      -> Miss[0]
        ro,
        0.001,
        rd,
        1e30,
        0   // payload location
    );

    imageStore(u_out, pix, payload);
}
